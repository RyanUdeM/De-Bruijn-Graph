import random
from collections.abc import MutableMapping
# from collections import MutableMapping # for python 3.5
from random import randrange
import time
# We built two functions: `debug` and `print_progress` for debugging during 
# development and show training progress respectively.

DEBUG = True
def debug(*args, **kwargs):
    global DEBUG
    if DEBUG:
        print(*args, **kwargs)
        

bases = "ACGT"

def random_seq(bases = bases, k = 21):
    return "".join(random.choices(bases, k = k))

# consider a DNA sequence with fixed length 21:
# there are at most: pow(4, 21) = 4^21 = 4398046511104 possible sequences.
def seq_hash_code(seq: str, k = 21) -> int:
    """convert a dna sequence (as a key) to a hash code
    params
        seq: dna sequence with bases from: 'A','T','C','G'
    returns
        code: hash code for key k, int 
    """
    return sum([bases.index(nt)<<(i*2) for i,nt in zip(range(k), seq)])


def code2seq(code: int, k = 21) -> str:
    """convert hash code back to dna sequence
    params
        code: hash code generated by methods: seq_hash_code and 
              seq_hash_code2, int
        bases: "AGCT" as default
    returns
        seq: an dna sequence with certain length
    """
    return ''.join([('A','C','G','T')[code >> (i*2) &3] for i in range(k) ])


class MyProbeHashMap(MutableMapping):
    """using MAD (multiply-add-and-divide, MAD) as compression 
    function and linear probing collision-handling scheme
    """
    class _Item:
        __slots__ = '_key', '_value'
        def __init__( self, k, v = None ):
            self._key = k
            self._value = v

        def __eq__( self, other ):
            return self._key == other._key

        def __ne__( self, other ):
            return not( self == other )

        def __lt__( self, other ):
            return self._key < other._key

        def __ge__( self, other ):
            return self._key >= other._key

        def __str__( self ):
            return "<" + str( self._key ) + "," + str( self._value ) + ">"

        def key( self ):
            return self._key

        def value( self ):
            return self._value    


    _AVAIL = object()
    _MIN_CAP = 11               # minimal capacity of the Map
    
    def __init__( self, cap = 11, ):
        cap = max(MyProbeHashMap._MIN_CAP, cap)  # minimal capacity of Map
        # is this prime p big enough for k = 21?
        self._T = cap * [None]                   # bucket array with cap entries
        self._size = 0                           # number of elements in array
        self._prime = 109345121                  # prime number for MAD compression
        # a: scale
        self._scale = 1 + randrange( self._prime - 1 ) # scale(also called: a) in [1, p-1]
        self._collisions = 0
        # seems we don't need this loop as p is prime
        trouve = False
        while not trouve:
            self._scale = 1 + randrange( self._prime - 1 )
            if not ( self._scale % self._prime ) == 0:
                trouve = True
        
        self._shift = randrange( self._prime )   # shift(also called: b) in [0, p-1]
        self._mask = cap                     # N
        self._q = 7                          # used for double hash
        self._max_load_factor = 0.75
        self._prob_func = self._probing_quadratic # addressing methods
        '''
        if probing == "quadratic":
            self._prob_func = self._probing_quadratic
        elif probing == "double_hash":
            self._prob_func = self._probing_double_hash
        ''' 
        
    # hash function using _hash_code and MAD compression function
    def _hash_function1( self, k ):
        tmp = seq_hash_code(k) * self._scale + self._shift 
        tmp = tmp  % self._prime % self._mask
        return tmp   
    
    def _hash_function(self, k):
        return seq_hash_code(k) % self._mask
        
    def get_load_factor(self):
        return self._size / len(self._T)
    
        
    # length (number of elements) in the table(T)
    def __len__( self ):
        return self._size

    def _is_available( self, j ):
        return self._T[j] is None or self._T[j] is MyProbeHashMap._AVAIL
    

    # three different probing methods to solve collision
    def _probing_linear(self, i, *args):
        return i
    
    def _probing_quadratic(self, i, *args):
        """probing quadratic"""
        return i*i
    
    def _probing_double_hash(self, i, k, *args):
        """double hashing
        f(i) = i * h'(k)
        h'(k) = q - (k mod q)
        """
        h_prime = self._q - (seq_hash_code(k) % self._q)
        return i * h_prime

    def _probing_random(self, i, k, *args):
        # this probing doesn't work well.
        random.seed(1)
        return i * random.randint(1, 7)
    
    def get_collisions(self):
        return self._collisions
    
    def reset_collisions(self):
        self._collisions = 0
        
    def _find_slot(self, j, k):
        """compared with _find_slot, this method support three different
        probing methods, and we can count the collision numbers
        """
        first_avail = None
        i = 0
        while True:
            new_j = (j + self._prob_func(i, k)) % len(self._T)
            if self._is_available(new_j):# May be None or _AVAIL
                if first_avail is None:
                    first_avail = new_j
                if self._T[new_j] is None:
                    return (False, first_avail)
            elif k == self._T[new_j]._key:
                return (True, new_j)
            # collision:
            i += 1
            self._collisions += 1

    def __iter__( self ):
        for j in range( len( self._T ) ):
            if not self._is_available( j ):
                yield self._T[j]._key

    def __getitem__( self, k ):
        j = self._hash_function( k )
        found, s = self._find_slot(j, k)
        if not found: # do not use value to check the condition,
            raise KeyError
        else:
            return self._T[s]._value

    def __setitem__( self, k, v ):
        j = self._hash_function( k )
        found, s = self._find_slot(j, k)
        if not found:
            self._T[s] = self._Item(k, v)
            self._size += 1
            if self._size > self._max_load_factor * len( self._T ):
                self._resize( 2 * len( self._T ) - 1 )
        else:
            self._T[s]._value = v


    def __delitem__( self, k ):
        j = self._hash_function( k )
        found, s = self._find_slot( j, k )
        if not found:
            raise KeyError

        value = self._T[s]._value
        self._T[s] = MyProbeHashMap._AVAIL
        self._size -= 1
        if self._size < len(self._T) // 4:
            new_cap = max(MyProbeHashMap._MIN_CAP, (len(self._T)+1) // 2)
            if new_cap != len(self._T):
                self._resize(new_cap)
        return value

    def _resize( self, c ):
        old = list( self.items() )
        self._T = c * [None]
        self._size = 0
        self._mask = c
        for (k,v) in old:
            self[k] = v

    def is_empty( self ):
        return len( self ) == 0

    def __str__( self ):
        if self.is_empty():
            return "{}"
        pp = "{"
        for item in self.items():
            pp += str( item )
        pp += "}"
        pp += " size = "
        pp += str( len( self ) )
        return pp

    def get( self, k, d = None ):
        try:
            tmp = self[k]
            return tmp
        except KeyError:
            return d

    def setdefault( self, k, d = None ):
        try:
            tmp = self[k]
            return tmp
        except:
            self[k] = d
            return d
        

class DeBrujinGraph:
    _bases = "ACTG"
    class Edge:
        __slots__ = '_origin', '_destin', '_element'
        
        def __init__( self, u, v, x ):
            self._origin = u
            self._destin = v
            self._element = x

        def endpoints( self ):
            return( self._origin, self._destin )

        def opposite( self, v ):
            return self._destin if v is self._origin else self._origin

        def element( self ):
            return self._element

        def __str__( self ):
            return str( self._element )

        def __hash__( self ):
            return seq_hash_code(self._origin + self._destin)
        

    def __init__(self, nodes: [str], k = 21):
        map_cap = (len(nodes) // 3) * 4 + 1
        self._outgoing = MyProbeHashMap(cap = map_cap)
        self._incoming = MyProbeHashMap(cap = map_cap)
        self._k = k
        self._edge_num = 0
        debug("building nodes...")
        for node in nodes: # insert all node into graph
            self._insert_node(node)
        # build edges
        debug("building edges...")
        for node in self.nodes():
            successors = [node[1:] + base for base in DeBrujinGraph._bases]
            for successor in successors:
                if successor in self:
                    self._insert_edge(node, successor, successor[-1])
    
    def __str__(self):
        s = "G( " + str(len(self._outgoing)) + " nodes{ "
        for v in self.nodes():
            s += str( v ) + " "
        s += "}, " + str(self._edge_num) + " edges{ "
        for e in self.edges():
            s += str( e ) + " "
        s += "} )"
        return s

    def _all_possible_successors(self, N: str) -> [str]:
        return [N[1:] + base for base in DeBrujinGraph._bases]

    def _all_possible_predecessors(self, N: str) -> [str]:
        return [base + N[:-1] for base in DeBrujinGraph._bases]
        
    def edges(self):
        for origin in self._outgoing:
            for successor in self.successors(origin):
                yield origin, successor
  
    def edge_count(self):
        '''
        i = 0
        print("in couting edges methods")
        for key in self._outgoing.keys():
            i += len(self._outgoing[key])
        return i
        '''
        return self._edge_num

    def _validate(self, x, edge = False):
        if x is None:
            raise ValueError("x is None")
        if not isinstance(x, str):
            raise TypeError("x should be an instance of str, now is:{}"\
                            .format(type(x)))
        if edge and (len(x) != 1 or x not in DeBrujinGraph._bases):
            raise ValueError("x should be one of character in ACTG")
        if not edge and (len(x) != self._k):
            raise ValueError("x should have {} characters".format(self._k))

    def _insert_node(self, x = None):
        self._outgoing[x] = MyProbeHashMap(cap = 7)
        self._incoming[x] = MyProbeHashMap(cap = 7)

    def _insert_edge(self, u, v, x = None):
        if self._outgoing[u].get(v) is None:
            edge = self.Edge(u, v, x)
            self._outgoing[u][v] = edge
            self._incoming[v][u] = edge
            self._edge_num += 1

    def _remove_edge(self, u, v):
        del self._outgoing[u][v]
        del self._incoming[v][u]
        self._edge_num -= 1
        
    def __contains__(self, N: str) -> bool:
        # détermine si le graphe de Brujin contient le noeud N
        return self._outgoing.get(N, None) is not None

    def load_factor(self) -> float:
        # calcule le facteur de charge de la table de hachage sous-jacente
        return self._outgoing.get_load_factor()
        
    def add(self, N: str):
        # ajoute le noeud N au graphe
        if N in self:
            print("{} already exits in graph, ignore it.".format(N))
            return 
        self._insert_node(N)
        successors = self._all_possible_successors(N)
        for successor in successors:
            if self._outgoing.get(successor) is not None:
                self._insert_edge(N, successor, successor[-1])
                
        predecessors = self._all_possible_predecessors(N)
        for predecessor in predecessors:
            if self._outgoing.get(predecessor) is not None:
                self._insert_edge(predecessor, N, N[-1])
                
    def remove(self, N: str):
        # self._validate(N)
        if not N in self:
            print("can't delete {}, it is not in graph".format(N))
            return
        for successor in self.successors(N):
            self._remove_edge(N, successor)
                
        for predecessor in self.predecessors(N):
            self._remove_edge(predecessor, N)
                
        del self._outgoing[N]
        del self._incoming[N]
        pass # enlève le noeud N du graphe
    
    def __iter__(self):
        # this method was implemented when the interface of this class is given.
        return self.nodes()
    
    def nodes(self):
        # retourne un itérable sur les noeuds du graphe
        # as the method __iter__(self) calls this method, we can not return 
        # a list of key
        # it will raise error when this method retrurns a list of key
        # it works well when we use yield from a generator.
        #return self._outgoing.keys()
        yield from self._outgoing.keys()
    
    def node_count(self):
        # return the total number of nodes
        return len(self._outgoing)

    def predecessors(self, N: str):
        # retourne tous les prédécesseur du noeud N
        # self._validate(N)
        result = []
        if len(self._incoming[N]) > 0:
            for key in self._incoming[N]:
                result.append(key)
        return result

    def successors(self, N: str):
        # retourne tous les successeurs du noeud N
        # self._validate(N)
        result = []
        if len(self._outgoing[N]) > 0:
            for key in self._outgoing[N]:
                result.append(key)
        return result


# =============== test codes =====================
# test hash code and code2seq
def test_hash_code(times = 1000):
    for _ in range(times):
        seq = random_seq()
        code1 = seq_hash_code(seq)
        seq2 = code2seq(code1)
        if seq != seq2:
            print("WRONG")
            print(seq)
            print(seq2)
            print(code1)
            return False
    print("success. test has code complete")
    print("largest  code '{}' comes from: {}".format(
        seq_hash_code("T"*21), "T"*21))
    print("smallest code '{}' comes from: {}".format(
        seq_hash_code("A"*21), "A"*21))
    return True

def test_hash_map():
    print("create an empty dict with capacity of 11")
    m = MyProbeHashMap(cap = 11)
    print("generate a seq")
    seq = random_seq(bases = bases, k = 100)
    print(seq)
    for i in range(len(seq)-1):
        s = seq[i:i+2]
        m[s] = s
    m["A"] = "A"
    print(m)
    print(m.get_collisions())
    print(m.get_load_factor())
    del m["A"]
    del m["CT"]
    print(m)
    m["C"] = "C"
    print(m)
    

def test_hash_map2():
    k = 21
    kmers = []
    seq = random_seq(bases = bases, k = 20000)
    kmers.extend([seq[i:i+k] for i in range(len(seq) - k + 1)])
    kmers = list(set(kmers))
    cap = (len(kmers) // 3) * 4 + 1
    m2 = MyProbeHashMap(cap = cap)
    for kmer in kmers:
        m2[kmer] = kmer
    print("{} keys, collisions: {}".format(len(kmers), m2.get_collisions()))

    has_error = False
    for key, value in m2.items():
        if m2[key] != value:
            print("Error, key != value")
            has_error = True
            break
    if not has_error:
        print("all keys == values")
        
    print("end test hashmap")
    print()
    

def test_graph():

    def print_predecessor_successor(graph):
        print("predecesors and successors")
        for node in graph.nodes():
            print("[ ", end = "")
            for predecessor in graph.predecessors(node):
                print("{} ".format(predecessor), end = "")
            print("] {} [ ".format(node), end = "")
            for successor in graph.successors(node):
                print("{} ".format(successor), end = "")
            print("]")

    seq = "ACTGAGTCATGGATG"
    k = 2
    kmers = [seq[i:i+k] for i in range(len(seq) - k + 1)]
    print("seq: ", seq)
    print("kmers: ", kmers)

    print("initialize graph with kmers and k")
    graph = DeBrujinGraph(kmers, k = k)
    print("after initialize, graph is:")
    print(graph)
    print(graph._edge_num)
    print("load_factor: ", graph.load_factor())
    print_predecessor_successor(graph)
    

    nodes_to_add = ["TT", "TA", "GT", "AA"]
    for node_to_add in nodes_to_add:
        print("add node ", node_to_add)
        graph.add(node_to_add)
        print("graph is:\n{}".format(graph))   
        print()

    print("all {} edges in graph:".format(graph.edge_count()))
    for edge in graph.edges():
        print(edge, end = " ")
    print()

    print("all {} nodes in graph:".format(graph.node_count()))
    for node in graph.nodes():
        print(node, end = " ")
    print()

    print("testing whether a node is in graph...")
    test_nodes = ["GG", "CG", "TA", "GC", "TT", "AA", "TT", "AG", "GT", "TG",\
     "GA", "AC"]
    for test_node in test_nodes:
        s = "{} is ".format(test_node)
        if not test_node in graph:
            s += "NOT "
        s += "in graph"
        print(s)
        

    print("testing delete node in graph...")
    deleting_nodes = ["GC", "CT", "TT", "AG", "AA", "CT", "AC", "GA", "GT",\
                      "TG"]
    for node in deleting_nodes:
        if node in graph:
            graph.remove(node)
            print("after remove {}, graph has {} edges".format(
                node, graph._edge_num))
            print(graph)
        else:
            print("node {} is not in graph, can't delete it".format(node))
        print()

    
    print_predecessor_successor(graph)
    
    print("load_factor: ", graph.load_factor())
    print("node count: ", graph.node_count())
    print("edge count: ", graph.edge_count())
    
    for key in graph.nodes():
        print(key, end = " ")
    print()
    
    for u, v in graph.edges():
        print(u, "->", v)
    print()


if __name__ == "__main__":
    print("unit testing...")
    test_hash_code()
    print()
    test_hash_map()
    print()
    test_hash_map2()
    print()
    test_graph()
    print("end unit test.")      
